import { ethers, waffle } from "hardhat";
import chai from "chai";
import { solidity } from "ethereum-waffle";
import { PalToken } from "../../typechain/PalToken";
import { PalPoolhPal } from "../../typechain/variants/PalPoolhPal";
import { PalLoanToken } from "../../typechain/PalLoanToken";
import { PaladinController } from "../../typechain/PaladinController";
import { InterestCalculator } from "../../typechain/interests/InterestCalculator";
import { IERC20 } from "../../typechain/utils/IERC20";
import { IhPAL } from "../../typechain/interfaces/IhPAL";
import { IERC20__factory } from "../../typechain/factories/utils/IERC20__factory";
import { IhPAL__factory } from "../../typechain/factories/interfaces/IhPAL__factory";
import { PalDelegatorClaimer } from "../../typechain/delegators/PalDelegatorClaimer";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import { ContractFactory } from "@ethersproject/contracts";
import { BigNumber } from "@ethersproject/bignumber";
import { getERC20 } from "../utils/getERC20";

chai.use(solidity);
const { expect } = chai;
const { provider } = ethers;

const mantissaScale = ethers.utils.parseEther('1')

let poolFactory: ContractFactory
let tokenFactory: ContractFactory
let controllerFactory: ContractFactory
let delegatorFactory: ContractFactory
let interestFactory: ContractFactory
let palLoanTokenFactory: ContractFactory

const PAL_address = "0xAB846Fb6C81370327e784Ae7CbB6d6a6af6Ff4BF" //PAL contract on mainnet
const hPAL_address = "0x624D822934e87D3534E435b83ff5C19769Efd9f6" //hPAL contract on mainnet

const PAL_holder = "0x0792dCb7080466e4Bbc678Bdb873FE7D969832B8"

describe('PalPool - hPAL version', () => {
    let admin: SignerWithAddress
    let user1: SignerWithAddress
    let user2: SignerWithAddress

    let pool: PalPoolhPal
    let token: PalToken
    let loanToken: PalLoanToken
    let controller: PaladinController
    let interest: InterestCalculator
    let delegator: PalDelegatorClaimer
    let pal: IERC20
    let hpal_erc20: IERC20
    let hpal: IhPAL

    let name: string = "Paladin MOCK"
    let symbol: string = "palMOCK"



    const mineBlocks = async (n: number): Promise<any> => {
        for(let i = 0; i < n; i++){
            await ethers.provider.send("evm_mine", [])
        }
        return Promise.resolve()
    }

    
    before( async () => {
        tokenFactory = await ethers.getContractFactory("PalToken");
        palLoanTokenFactory = await ethers.getContractFactory("PalLoanToken");
        poolFactory = await ethers.getContractFactory("PalPoolhPal");
        controllerFactory = await ethers.getContractFactory("PaladinController");
        delegatorFactory = await ethers.getContractFactory("PalDelegatorClaimer");
        interestFactory = await ethers.getContractFactory("InterestCalculator");


        [admin, user1, user2] = await ethers.getSigners();

        pal = IERC20__factory.connect(PAL_address, provider);
        hpal_erc20 = IERC20__factory.connect(hPAL_address, provider);
        hpal = IhPAL__factory.connect(hPAL_address, provider);


        const staking_amount = ethers.utils.parseEther('100000')

        await getERC20(admin, PAL_holder, pal, admin.address, staking_amount);

        await pal.connect(admin).approve(hPAL_address, staking_amount)

        await hpal.connect(admin).stake(staking_amount)
    })


    beforeEach( async () => {

        token = (await tokenFactory.connect(admin).deploy(name, symbol)) as PalToken;
        await token.deployed();

        controller = (await controllerFactory.connect(admin).deploy()) as PaladinController;
        await controller.deployed();

        loanToken = (await palLoanTokenFactory.connect(admin).deploy(controller.address, "about:blank")) as PalLoanToken;
        await loanToken.deployed();

        interest = (await interestFactory.connect(admin).deploy()) as InterestCalculator;
        await interest.deployed();

        delegator = (await delegatorFactory.connect(admin).deploy()) as PalDelegatorClaimer;
        await delegator.deployed();

        pool = (await poolFactory.connect(admin).deploy(
            token.address,
            controller.address, 
            hpal.address,
            interest.address,
            delegator.address,
            loanToken.address,
            pal.address
        )) as PalPoolhPal;
        await pool.deployed();

        await token.initiate(pool.address);

        await controller.addNewPool(token.address, pool.address);
    });

    describe('claim rewards generated by hPAL', async () => {

        const deposit_amount = ethers.utils.parseEther('1000')
        const deposit2_amount = ethers.utils.parseEther('500')
        const withdraw_amount = ethers.utils.parseEther('500')
        const borrow_amount = ethers.utils.parseEther('100')
        const expand_amount = ethers.utils.parseEther('50')
        const fees_amount = ethers.utils.parseEther('10')

        beforeEach(async () => {
            await hpal_erc20.connect(admin).transfer(user1.address, ethers.utils.parseEther('1500'))

            await hpal_erc20.connect(user1).approve(pool.address, ethers.utils.parseEther('1500'))
        });


        it(' should claim correctly and stake the whole PAL balance in hPAL ', async () => {
            await pool.connect(user1).deposit(deposit_amount)
            
            await mineBlocks(50)

            const previous_pool_hpal_rewardIndex = await hpal.userRewardIndex(pool.address)

            const previous_pool_hpal_balance = await hpal_erc20.balanceOf(pool.address)

            const update_tx = await pool.claimPal()

            const new_pool_hpal_rewardIndex = await hpal.userRewardIndex(pool.address)

            const new_pool_hpal_balance = await hpal_erc20.balanceOf(pool.address)

            const index_diff = new_pool_hpal_rewardIndex.sub(previous_pool_hpal_rewardIndex)

            const expected_accrued_rewards = previous_pool_hpal_balance.mul(index_diff).div(mantissaScale)

            expect(new_pool_hpal_balance.sub(previous_pool_hpal_balance)).to.be.eq(expected_accrued_rewards)

            const update_ts = (await ethers.provider.getBlock((await update_tx).blockNumber || 0)).timestamp

            expect(await hpal.rewardsLastUpdate(pool.address)).to.be.eq(update_ts)

            expect(await pal.balanceOf(pool.address)).to.be.eq(0)
            
        });


        it(' deposit only scenario ', async () => {
            await pool.connect(user1).deposit(deposit_amount)
            
            await mineBlocks(50)

            await pool.connect(user1).deposit(deposit2_amount)

            //Pool should hold more stkAave than what's been deposited (twice) : claimed->restaked rewards
            expect(await pool.underlyingBalance()).to.be.gt(deposit_amount.add(deposit2_amount))
        });


        it(' deposit - withdraw scenario ', async () => {
            await pool.connect(user1).deposit(deposit_amount)
            
            await mineBlocks(50)

            await pool.connect(user1).withdraw(withdraw_amount)

            //Pool should hold more hPAL than what's been (deposited - withdrawn) : claimed->restaked rewards
            expect(await pool.underlyingBalance()).to.be.gt(deposit_amount.sub(withdraw_amount))
        });


        it(' borrow scenario ', async () => {
            await pool.connect(user1).deposit(deposit_amount)
            
            await mineBlocks(50)

            await pool.connect(user1).borrow(user1.address, borrow_amount, fees_amount)

            //Pool should hold more hPAL than what's been (deposited - borrowed) : claimed->restaked rewards
            expect(await pool.underlyingBalance()).to.be.gt(deposit_amount.sub(borrow_amount))
        });


        it(' borrow - expandBorrow scenario ', async () => {
            await pool.connect(user1).deposit(deposit_amount)

            await pool.connect(user1).borrow(user1.address, borrow_amount, fees_amount)
            
            const before_pool_underlying_balance = await pool.underlyingBalance()

            await mineBlocks(50)

            const loan_address = (await pool.getLoansPools())[0]
            await pool.connect(user1).expandBorrow(loan_address, expand_amount)

            const after_pool_underlying_balance = await pool.underlyingBalance()

            expect(after_pool_underlying_balance).to.be.gt(before_pool_underlying_balance)
        });

        it(' borrow - changeDelegatee scenario ', async () => {
            await pool.connect(user1).deposit(deposit_amount)

            await pool.connect(user1).borrow(user1.address, borrow_amount, fees_amount)
            
            const before_pool_underlying_balance = await pool.underlyingBalance()

            await mineBlocks(50)

            const loan_address = (await pool.getLoansPools())[0]
            await pool.connect(user1).changeBorrowDelegatee(loan_address, user2.address)

            const after_pool_underlying_balance = await pool.underlyingBalance()

            expect(after_pool_underlying_balance).to.be.gt(before_pool_underlying_balance)
        });

    });


    describe('palLoan returns generated rewards to the Pool', async () => {

        const deposit = ethers.utils.parseEther('1000')

        const borrow_amount = ethers.utils.parseEther('100')

        const fees_amount = ethers.utils.parseEther('5')

        const kill_fees_amount = ethers.utils.parseEther('0.004')


        beforeEach(async () => {
            await hpal_erc20.connect(admin).transfer(user2.address, deposit)
            await hpal_erc20.connect(admin).transfer(user1.address, fees_amount)

            await hpal_erc20.connect(user1).approve(pool.address, fees_amount)
            await hpal_erc20.connect(user2).approve(pool.address, deposit)

            await pool.connect(admin).updateMinBorrowLength(100)

            await pool.connect(user2).deposit(deposit)
        });


        it(' should receive PAL tokens from rewards - CloseBorrow ', async () => {
            await pool.connect(user1).borrow(user1.address, borrow_amount, fees_amount)

            const loan_address = (await pool.getLoansPools())[0]
            const minBorrowLength = await pool.minBorrowLength()

            await mineBlocks(minBorrowLength.toNumber() + 1)

            await pool.connect(user1).closeBorrow(loan_address)

            expect(await pal.balanceOf(pool.address)).not.to.be.eq(0)
            
        });


        it(' should receive PAL tokens from rewards - KillBorrow ', async () => {
            await pool.connect(user1).borrow(user1.address, borrow_amount, kill_fees_amount)

            const loan_address = (await pool.getLoansPools())[0]

            await mineBlocks(170)

            await pool.connect(user2).killBorrow(loan_address)

            expect(await pal.balanceOf(pool.address)).not.to.be.eq(0)
        });

    });

});